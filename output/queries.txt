
        CREATE CONSTRAINT phenotypeIdConstraint FOR (p:Phenotype) REQUIRE p.id IS UNIQUE;
    ;

        CREATE CONSTRAINT geneIdConstraint FOR (g:Gene) REQUIRE g.id IS UNIQUE;
    ;

        CREATE CONSTRAINT variantIdConstraint FOR (v:Variant) REQUIRE v.id IS UNIQUE;
    ;

        CREATE CONSTRAINT drugIdConstraint FOR (d:Drug) REQUIRE d.id IS UNIQUE;
    ;

        CREATE CONSTRAINT molecularfunctionIdConstraint FOR (m:MolecularFunction) REQUIRE m.id IS UNIQUE;
    ;

        CREATE CONSTRAINT genotypeIdConstraint FOR (g:Genotype) REQUIRE g.id IS UNIQUE;
    ;

        CREATE CONSTRAINT modelIdConstraint FOR (m:Model) REQUIRE m.id IS UNIQUE;
    ;

        CREATE CONSTRAINT diseaseIdConstraint FOR (d:Disease) REQUIRE d.id IS UNIQUE;
    ;

        CREATE CONSTRAINT anatomicalentityIdConstraint FOR (a:AnatomicalEntity) REQUIRE a.id IS UNIQUE;
    ;

        CREATE CONSTRAINT biologicalprocessIdConstraint FOR (b:BiologicalProcess) REQUIRE b.id IS UNIQUE;
    ;

        CREATE CONSTRAINT chemicalIdConstraint FOR (c:Chemical) REQUIRE c.id IS UNIQUE;
    ;

        CREATE CONSTRAINT cellularcomponentIdConstraint FOR (c:CellularComponent) REQUIRE c.id IS UNIQUE;
    ;

        CREATE CONSTRAINT pathwayIdConstraint FOR (p:Pathway) REQUIRE p.id IS UNIQUE;
    ;

        LOAD CSV WITH HEADERS FROM 'file:///query_nodes.csv' AS row
        CALL apoc.merge.node([row.semantic_label], {id: row.id, label: row.label, iri: row.iri})
        YIELD node
        RETURN node
    ;

        LOAD CSV WITH HEADERS FROM 'file:///query_edges.csv' AS row
        MATCH (n1 {id: row.subject}), (n2 {id: row.object})
        WITH n1, n2, row
        CALL apoc.create.relationship(n1, row.relation_label, {id: row.id}, n2) 
        YIELD rel
        RETURN rel
    